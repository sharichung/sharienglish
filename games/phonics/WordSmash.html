<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Smash!</title>
    <script src="/_sdk/data_sdk.js"></script>
    <script src="/_sdk/element_sdk.js"></script>
    <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            height: 100%;
            overflow: hidden;
        }

        .game-container {
            width: 100%;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 50%, #45B7D1 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .start-screen h1 {
            font-size: 4rem;
            color: white;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
            margin-bottom: 2rem;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {

            0%,
            20%,
            50%,
            80%,
            100% {
                transform: translateY(0);
            }

            40% {
                transform: translateY(-20px);
            }

            60% {
                transform: translateY(-10px);
            }
        }

        .menu-buttons {
            display: flex;
            gap: 2rem;
            flex-direction: column;
            align-items: center;
        }

        .btn {
            padding: 1rem 2rem;
            font-size: 1.5rem;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-width: 200px;
        }

        .btn-start {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
        }

        .btn-words {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .word-list-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: none;
            flex-direction: column;
            padding: 2rem;
            z-index: 999;
        }

        .word-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .word-list-header h2 {
            color: white;
            font-size: 2.5rem;
            margin: 0;
        }

        .btn-back {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
            padding: 0.8rem 1.5rem;
            font-size: 1.2rem;
        }

        .word-input-section {
            background: rgba(255, 255, 255, 0.9);
            padding: 2rem;
            border-radius: 20px;
            margin-bottom: 2rem;
        }

        .word-input-section h3 {
            margin-top: 0;
            color: #333;
            font-size: 1.5rem;
        }

        .input-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .tab-btn {
            padding: 0.6rem 1.2rem;
            font-size: 1rem;
            border: 2px solid #ddd;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab-btn.active {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            border-color: #4ECDC4;
        }

        .tab-btn:hover:not(.active) {
            border-color: #4ECDC4;
            background: #f0f9ff;
        }

        .tab-content {
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .word-input-form {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .batch-input-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .batch-input {
            padding: 1rem;
            font-size: 1.1rem;
            border: 2px solid #ddd;
            border-radius: 10px;
            resize: vertical;
            font-family: inherit;
            min-height: 120px;
        }

        .batch-input:focus {
            border-color: #4ECDC4;
            outline: none;
        }

        .batch-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .btn-clear {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
            color: white;
            padding: 0.8rem 1.5rem;
            font-size: 1.2rem;
        }

        .batch-preview {
            background: #f8f9fa;
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 1rem;
            min-height: 60px;
            display: none;
        }

        .batch-preview.show {
            display: block;
        }

        .preview-words {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .preview-word {
            background: #e3f2fd;
            color: #1976d2;
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            font-size: 0.9rem;
            border: 1px solid #bbdefb;
        }

        .preview-word.duplicate {
            background: #ffebee;
            color: #d32f2f;
            border-color: #ffcdd2;
        }

        .preview-stats {
            font-size: 0.9rem;
            color: #666;
            font-weight: bold;
        }

        .word-input {
            padding: 0.8rem;
            font-size: 1.2rem;
            border: 2px solid #ddd;
            border-radius: 10px;
            min-width: 200px;
        }

        .btn-add {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            padding: 0.8rem 1.5rem;
            font-size: 1.2rem;
        }

        .words-grid {
            background: rgba(255, 255, 255, 0.9);
            padding: 2rem;
            border-radius: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .words-grid h3 {
            margin-top: 0;
            color: #333;
            font-size: 1.5rem;
        }

        .word-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .word-tag {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
            padding: 0.8rem 1.2rem;
            border-radius: 20px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .word-delete {
            background: rgba(255, 255, 255, 0.3);
            border: none;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .game-screen {
            display: none;
            width: 100%;
            height: 100vh;
            position: relative;
        }

        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.9);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .game-controls {
            display: flex;
            gap: 1rem;
        }

        .btn-end {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: white;
            padding: 0.6rem 1.2rem;
            font-size: 1rem;
        }

        .score {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
        }

        .hearts {
            display: flex;
            gap: 0.5rem;
        }

        .heart {
            font-size: 2rem;
            color: #FF6B6B;
        }

        .game-area {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .ground {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            background: linear-gradient(to bottom, #90EE90, #228B22);
            border-top: 5px solid #32CD32;
        }

        .rock-launcher {
            position: absolute;
            bottom: 150px;
            left: 100px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #8B4513, #A0522D);
            border-radius: 50%;
            border: 3px solid #654321;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            z-index: 50;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .projectile {
            position: absolute;
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #696969, #808080);
            border-radius: 50%;
            border: 2px solid #2F4F4F;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            z-index: 60;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .projectile.flying {
            animation: rockFly 1s ease-out forwards;
        }

        @keyframes rockFly {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }

            50% {
                transform: translate(300px, -80px) scale(0.8);
                opacity: 0.9;
            }

            100% {
                transform: translate(600px, 0) scale(0.6);
                opacity: 0.7;
            }
        }

        .obstacle {
            position: absolute;
            bottom: 150px;
            right: -150px;
            width: 120px;
            height: 80px;
            background: linear-gradient(45deg, #8B4513, #A0522D);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            border: 3px solid #654321;
            animation: moveLeft 16s linear;
        }

        @keyframes moveLeft {
            from {
                right: -150px;
            }

            to {
                right: calc(100% + 150px);
            }
        }


        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 1rem 2rem;
            border-radius: 20px;
            font-size: 1.2rem;
            color: #333;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 3rem;
            border-radius: 30px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 200;
        }

        .game-over h2 {
            color: #FF6B6B;
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .game-over p {
            font-size: 1.3rem;
            color: #333;
            margin-bottom: 2rem;
        }

        .celebration-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #FFD700, #FFA500);
            padding: 3rem;
            border-radius: 30px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 200;
            color: white;
            min-width: 400px;
        }

        .celebration-screen h2 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .celebration-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 2rem;
            gap: 1rem;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.2);
            padding: 1.5rem;
            border-radius: 20px;
            flex: 1;
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .stat-label {
            font-size: 1rem;
            opacity: 0.9;
            text-align: center;
        }

        .celebration-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            z-index: 1001;
            display: none;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .celebration-burst {
            position: absolute;
            pointer-events: none;
            z-index: 70;
        }

        .celebration-particle {
            position: absolute;
            font-size: 1.5rem;
            animation: burstOut 1s ease-out forwards;
        }

        @keyframes burstOut {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translate(var(--dx), var(--dy)) scale(0.3);
                opacity: 0;
            }
        }

        .hit-flash {
            position: absolute;
            width: 150px;
            height: 100px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.8) 0%, rgba(255, 165, 0, 0.6) 50%, transparent 100%);
            border-radius: 50%;
            animation: flashEffect 0.5s ease-out forwards;
            pointer-events: none;
            z-index: 65;
        }

        @keyframes flashEffect {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }

            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
    </style>
    <style>
        @view-transition {
            navigation: auto;
        }
    </style>
    <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
</head>

<body>
    <div class="game-container">
        <!-- Loading Screen -->
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Loading game...</p>
        </div><!-- Start Screen -->
        <div class="start-screen" id="startScreen">
            <h1 id="gameTitle">Word Smash!</h1>
            <div class="menu-buttons"><button class="btn btn-start" onclick="startGame()">ü™® Start Game</button> <button
                    class="btn btn-words" onclick="showWordList()">üìù Word List</button>
            </div>
        </div><!-- Word List Screen -->
        <div class="word-list-screen" id="wordListScreen">
            <div class="word-list-header">
                <h2>Manage Words</h2><button class="btn btn-back" onclick="showStartScreen()">‚Üê Back</button>
            </div>
            <div class="word-input-section">
                <h3>Add New Words</h3>
                <div class="input-tabs"><button class="tab-btn active" onclick="switchTab('single')">Single
                        Word</button> <button class="tab-btn" onclick="switchTab('batch')">Batch Import</button>
                </div>
                <div class="tab-content" id="singleTab">
                    <div class="word-input-form"><input type="text" class="word-input" id="newWordInput"
                            placeholder="Enter a word..." maxlength="20"> <button class="btn btn-add"
                            onclick="addWord()">Add Word</button>
                    </div>
                </div>
                <div class="tab-content" id="batchTab" style="display: none;">
                    <div class="batch-input-form"><textarea class="batch-input" id="batchWordInput" placeholder="Paste your word list here... (one word per line or separated by commas)

Example:
the
said
one
was

Or: the, said, one, was" rows="6"></textarea>
                        <div class="batch-controls"><button class="btn btn-add" onclick="addBatchWords()">Import
                                Words</button> <button class="btn btn-clear" onclick="clearBatchInput()">Clear</button>
                        </div>
                        <div class="batch-preview" id="batchPreview"></div>
                    </div>
                </div>
            </div>
            <div class="words-grid">
                <h3>Current Words (<span id="wordCount">0</span>)</h3>
                <div class="word-tags" id="wordTags">
                    <!-- Words will be displayed here -->
                </div>
            </div>
        </div><!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <div class="game-ui">
                <div class="score">
                    Score: <span id="score">0</span>
                </div>
                <div class="game-controls"><button class="btn btn-back" onclick="showStartScreen()">‚Üê Back</button>
                    <button class="btn btn-end" onclick="endGameCelebration()">üéâ End Game</button>
                </div>
                <div class="hearts" id="hearts"><span class="heart">‚ù§Ô∏è</span> <span class="heart">‚ù§Ô∏è</span> <span
                        class="heart">‚ù§Ô∏è</span> <span class="heart">‚ù§Ô∏è</span> <span class="heart">‚ù§Ô∏è</span>
                </div>
            </div>
            <div class="game-area">
                <div class="ground"></div>
                <div class="rock-launcher" id="rockLauncher"><span id="launcherIcon">ü™®</span>
                </div>
                <div class="instructions" id="instructions">
                    Read the word aloud, then press SPACE to hit!
                </div>
            </div>
            <div class="game-over" id="gameOver">
                <h2>Game Over!</h2>
                <p>Final Score: <span id="finalScore">0</span></p><button class="btn btn-start"
                    onclick="showStartScreen()">Play Again</button>
            </div>
            <div class="celebration-screen" id="celebrationScreen">
                <h2>üéâ Great Job! üéâ</h2>
                <div class="celebration-stats">
                    <div class="stat-item"><span class="stat-number" id="wordsHitCount">0</span> <span
                            class="stat-label">Words Hit Correctly</span>
                    </div>
                    <div class="stat-item"><span class="stat-number" id="wordsMissedCount">0</span> <span
                            class="stat-label">Words Missed</span>
                    </div>
                    <div class="stat-item"><span class="stat-number" id="celebrationScore">0</span> <span
                            class="stat-label">Total Score</span>
                    </div>
                </div>
                <div class="celebration-buttons"><button class="btn btn-start" onclick="startGame()">ü™® Play
                        Again</button> <button class="btn btn-back" onclick="showStartScreen()">‚Üê Main Menu</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Game state
        let gameState = {
            score: 0,
            hearts: 5,
            isPlaying: false,
            currentObstacle: null,
            obstacleInterval: null,
            gameWords: [],
            wordsHit: 0,
            wordsMissed: 0,
        };

        // Data SDK setup
        let currentWords = [];
        let currentRecordCount = 0;

        const dataHandler = {
            onDataChanged(data) {
                currentWords = data;
                currentRecordCount = data.length;
                updateWordDisplay();
                gameState.gameWords = data.map(item => item.word);
            }
        };

        // Element SDK setup
        const defaultConfig = {
            game_title: "Word Smash!",
            runner_name: "ü™®",
            instructions_text: "Read the word aloud, then press SPACE to hit!"
        };

        let config = defaultConfig;

        async function onConfigChange(newConfig) {
            config = {
                ...defaultConfig,
                ...newConfig
            };

            // Update UI elements
            const titleElement = document.getElementById('gameTitle');
            if (titleElement) {
                titleElement.textContent = config.game_title || defaultConfig.game_title;
            }

            const launcherElement = document.getElementById('launcherIcon');
            if (launcherElement) {
                launcherElement.textContent = config.runner_name || defaultConfig.runner_name;
            }

            const instructionsElement = document.getElementById('instructions');
            if (instructionsElement) {
                instructionsElement.textContent = config.instructions_text || defaultConfig.instructions_text;
            }
        }

        // Initialize SDKs
        async function initializeApp() {
            document.getElementById('loading').style.display = 'block';

            try {
                // Initialize Data SDK
                if (window.dataSdk) {
                    const initResult = await window.dataSdk.init(dataHandler);
                    if (!initResult.isOk) {
                        console.error("Failed to initialize data SDK");
                    }
                }

                // Initialize Element SDK
                if (window.elementSdk) {
                    await window.elementSdk.init({
                        defaultConfig,
                        onConfigChange,
                        mapToCapabilities: (config) => ({
                            recolorables: [],
                            borderables: [],
                            fontEditable: undefined,
                            fontSizeable: undefined
                        }),
                        mapToEditPanelValues: (config) => new Map([
                            ["game_title", config.game_title || defaultConfig.game_title],
                            ["runner_name", config.runner_name || defaultConfig.runner_name],
                            ["instructions_text", config.instructions_text || defaultConfig
                                .instructions_text
                            ]
                        ])
                    });

                    config = window.elementSdk.config;
                    await onConfigChange(config);
                }
            } catch (error) {
                console.error("Error initializing SDKs:", error);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Word management functions
        function updateWordDisplay() {
            const wordTags = document.getElementById('wordTags');
            const wordCount = document.getElementById('wordCount');

            wordCount.textContent = currentWords.length;
            wordTags.innerHTML = '';

            currentWords.forEach(wordData => {
                const tag = document.createElement('div');
                tag.className = 'word-tag';
                tag.innerHTML = `
                    ${wordData.word}
                    <button class="word-delete" onclick="deleteWord('${wordData.__backendId}')" title="Delete word">√ó</button>
                `;
                wordTags.appendChild(tag);
            });
        }

        async function addWord() {
            const input = document.getElementById('newWordInput');
            const word = input.value.trim().toLowerCase();

            if (!word) return;

            if (currentRecordCount >= 999) {
                showMessage("Maximum limit of 999 words reached. Please delete some words first.");
                return;
            }

            // Check for duplicates
            if (currentWords.some(w => w.word === word)) {
                showMessage("This word already exists!");
                return;
            }

            showLoading(true);

            if (window.dataSdk) {
                const result = await window.dataSdk.create({
                    word: word,
                    difficulty: "basic"
                });

                if (result.isOk) {
                    input.value = '';
                } else {
                    showMessage("Failed to add word. Please try again.");
                }
            }

            showLoading(false);
        }

        async function deleteWord(backendId) {
  const index = currentWords.findIndex(w => w.__backendId === backendId);
  if (index === -1) return;

  showLoading(true);

  if (window.dataSdk) {
    const result = await window.dataSdk.delete(currentWords[index]);
    if (!result.isOk) {
      showMessage("Failed to delete word. Please try again.");
    }
  } else {
    // Local fallback: remove directly
    currentWords.splice(index, 1);
    currentRecordCount = currentWords.length;
    gameState.gameWords = currentWords.map(item => item.word);
    updateWordDisplay();
  }

  showLoading(false);
}

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function showMessage(message) {
            // Create a simple toast message
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #FF6B6B;
                color: white;
                padding: 1rem 2rem;
                border-radius: 10px;
                z-index: 2000;
                font-size: 1.1rem;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                document.body.removeChild(toast);
            }, 3000);
        }

        // Screen navigation
        function showStartScreen() {
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('wordListScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
            stopGame();
        }

        function showWordList() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('wordListScreen').style.display = 'flex';
            document.getElementById('gameScreen').style.display = 'none';
        }

        function startGame() {
            if (gameState.gameWords.length === 0) {
                showMessage("Please add some words first!");
                return;
            }

            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('wordListScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';

            resetGame();
            gameState.isPlaying = true;

            // Start spawning obstacles
            gameState.obstacleInterval = setInterval(spawnObstacle, 6000);
        }

        function resetGame() {
            gameState.score = 0;
            gameState.hearts = 5;
            gameState.currentObstacle = null;
            gameState.wordsHit = 0;
            gameState.wordsMissed = 0;

            updateUI();

            // Clear any existing obstacles
            const existingObstacles = document.querySelectorAll('.obstacle');
            existingObstacles.forEach(obs => obs.remove());

            // Clear any projectiles
            const existingProjectiles = document.querySelectorAll('.projectile');
            existingProjectiles.forEach(proj => proj.remove());

            // Hide game over and celebration screens
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('celebrationScreen').style.display = 'none';
        }

        function stopGame() {
            gameState.isPlaying = false;
            if (gameState.obstacleInterval) {
                clearInterval(gameState.obstacleInterval);
                gameState.obstacleInterval = null;
            }
        }

        function spawnObstacle() {
            if (!gameState.isPlaying || gameState.gameWords.length === 0) return;

            const obstacle = document.createElement('div');
            obstacle.className = 'obstacle';

            // Pick a random word
            const randomWord = gameState.gameWords[Math.floor(Math.random() * gameState.gameWords.length)];
            obstacle.textContent = randomWord;
            obstacle.dataset.missed = 'false';

            document.querySelector('.game-area').appendChild(obstacle);
            gameState.currentObstacle = obstacle;

           // Remove obstacle after animation (match CSS duration)
const duration = parseFloat(getComputedStyle(obstacle).animationDuration) * 1000;

setTimeout(() => {
    if (obstacle.parentNode && obstacle.dataset.missed === 'false') {
        // Player missed the word - lose a heart
        loseHeart();
        obstacle.remove();
        if (gameState.currentObstacle === obstacle) {
            gameState.currentObstacle = null;
        }
    }
}, duration);

        }

        function throwRock() {
            if (!gameState.isPlaying || !gameState.currentObstacle) return;

            // Mark obstacle as hit (not missed)
            gameState.currentObstacle.dataset.missed = 'true';

            // Create projectile rock
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            projectile.innerHTML = 'ü™®';

            // Position at launcher
            const launcher = document.getElementById('rockLauncher');
            const launcherRect = launcher.getBoundingClientRect();
            const gameArea = document.querySelector('.game-area');
            const gameRect = gameArea.getBoundingClientRect();

            projectile.style.left = (launcherRect.left - gameRect.left + 30) + 'px';
            projectile.style.bottom = '180px';

            gameArea.appendChild(projectile);

            // Start flying animation
            projectile.classList.add('flying');

            // Score points for successful hit
            gameState.score += 10;
            gameState.wordsHit++;
            updateUI();

            // Create celebration effect at obstacle position
            createCelebrationEffect(gameState.currentObstacle);

            // Remove the obstacle
            if (gameState.currentObstacle.parentNode) {
                gameState.currentObstacle.remove();
            }
            gameState.currentObstacle = null;

            // Remove projectile after animation
            setTimeout(() => {
                if (projectile.parentNode) {
                    projectile.remove();
                }
            }, 1000);
        }

        function loseHeart() {
            gameState.hearts--;
            gameState.wordsMissed++;
            updateUI();

            if (gameState.hearts <= 0) {
                endGame();
            }
        }

        function endGame() {
            stopGame();
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;

            const heartsContainer = document.getElementById('hearts');
            heartsContainer.innerHTML = '';
            for (let i = 0; i < gameState.hearts; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart';
                heart.textContent = '‚ù§Ô∏è';
                heartsContainer.appendChild(heart);
            }
        }

        function createCelebrationEffect(obstacle) {
            const obstacleRect = obstacle.getBoundingClientRect();
            const gameArea = document.querySelector('.game-area');
            const gameRect = gameArea.getBoundingClientRect();

            // Create flash effect
            const flash = document.createElement('div');
            flash.className = 'hit-flash';
            flash.style.left = (obstacleRect.left - gameRect.left - 15) + 'px';
            flash.style.bottom = '130px';
            gameArea.appendChild(flash);

            // Create particle burst
            const burst = document.createElement('div');
            burst.className = 'celebration-burst';
            burst.style.left = (obstacleRect.left - gameRect.left + 60) + 'px';
            burst.style.bottom = '190px';

            // Create multiple particles
            const particles = ['‚≠ê', '‚ú®', 'üéâ', 'üí´', 'üåü'];
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'celebration-particle';
                particle.textContent = particles[Math.floor(Math.random() * particles.length)];

                // Random direction for each particle
                const angle = (i / 8) * 2 * Math.PI;
                const distance = 60 + Math.random() * 40;
                const dx = Math.cos(angle) * distance;
                const dy = Math.sin(angle) * distance;

                particle.style.setProperty('--dx', dx + 'px');
                particle.style.setProperty('--dy', dy + 'px');

                burst.appendChild(particle);
            }

            gameArea.appendChild(burst);

            // Clean up effects after animation
            setTimeout(() => {
                if (flash.parentNode) flash.remove();
                if (burst.parentNode) burst.remove();
            }, 1000);
        }

        function endGameCelebration() {
            stopGame();

            // Update celebration screen with stats
            document.getElementById('wordsHitCount').textContent = gameState.wordsHit;
            document.getElementById('wordsMissedCount').textContent = gameState.wordsMissed;
            document.getElementById('celebrationScore').textContent = gameState.score;

            // Show celebration screen
            document.getElementById('celebrationScreen').style.display = 'block';
        }

        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                throwRock();
            }
        });

        // Tab switching functionality
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Show/hide tab content
            document.getElementById('singleTab').style.display = tabName === 'single' ? 'block' : 'none';
            document.getElementById('batchTab').style.display = tabName === 'batch' ? 'block' : 'none';

            // Clear preview when switching away from batch
            if (tabName !== 'batch') {
                document.getElementById('batchPreview').classList.remove('show');
            }
        }

        // Batch word processing
        function parseBatchWords(text) {
            if (!text.trim()) return [];

            // Split by newlines first, then by commas, then filter and clean
            const words = text
                .split(/[\n,]+/)
                .map(word => word.trim().toLowerCase())
                .filter(word => word.length > 0 && word.length <= 20)
                .filter(word => /^[a-zA-Z\s'-]+$/.test(word)); // Only allow letters, spaces, apostrophes, hyphens

            // Remove duplicates
            return [...new Set(words)];
        }

        function previewBatchWords() {
            const input = document.getElementById('batchWordInput');
            const preview = document.getElementById('batchPreview');
            const text = input.value;

            if (!text.trim()) {
                preview.classList.remove('show');
                return;
            }

            const words = parseBatchWords(text);
            const existingWords = currentWords.map(w => w.word);
            const newWords = words.filter(word => !existingWords.includes(word));
            const duplicates = words.filter(word => existingWords.includes(word));

            let previewHTML = '<div class="preview-words">';

            // Show new words
            newWords.forEach(word => {
                previewHTML += `<span class="preview-word">${word}</span>`;
            });

            // Show duplicates
            duplicates.forEach(word => {
                previewHTML += `<span class="preview-word duplicate" title="Already exists">${word}</span>`;
            });

            previewHTML += '</div>';
            previewHTML += `<div class="preview-stats">`;
            previewHTML += `${newWords.length} new words to import`;
            if (duplicates.length > 0) {
                previewHTML += ` ‚Ä¢ ${duplicates.length} duplicates (will be skipped)`;
            }
            previewHTML += `</div>`;

            preview.innerHTML = previewHTML;
            preview.classList.add('show');
        }

        async function addBatchWords() {
            const input = document.getElementById('batchWordInput');
            const text = input.value.trim();

            if (!text) {
                showMessage("Please enter some words to import!");
                return;
            }

            const words = parseBatchWords(text);
            const existingWords = currentWords.map(w => w.word);
            const newWords = words.filter(word => !existingWords.includes(word));

            if (newWords.length === 0) {
                showMessage("No new words to import!");
                return;
            }

            if (currentRecordCount + newWords.length > 999) {
                showMessage(`Cannot import ${newWords.length} words. Maximum limit is 999 words total.`);
                return;
            }

            showLoading(true);

            let successCount = 0;
            let errorCount = 0;

            // Import words one by one
            for (const word of newWords) {
                if (window.dataSdk) {
                    const result = await window.dataSdk.create({
                        word: word,
                        difficulty: "basic"
                    });

                    if (result.isOk) {
                        successCount++;
                    } else {
                        errorCount++;
                    }
                }
            }

            showLoading(false);

            if (successCount > 0) {
                input.value = '';
                document.getElementById('batchPreview').classList.remove('show');
                showMessage(`Successfully imported ${successCount} words!`);

                // Switch back to single word tab
                switchTab('single');
                document.querySelector('.tab-btn').click();
            }

            if (errorCount > 0) {
                showMessage(`${errorCount} words failed to import. Please try again.`);
            }
        }

        function clearBatchInput() {
            document.getElementById('batchWordInput').value = '';
            document.getElementById('batchPreview').classList.remove('show');
        }

        // Handle Enter key in word input
        document.getElementById('newWordInput').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                addWord();
            }
        });

        // Handle batch input changes for live preview
        document.addEventListener('DOMContentLoaded', () => {
            const batchInput = document.getElementById('batchWordInput');
            if (batchInput) {
                batchInput.addEventListener('input', previewBatchWords);
                batchInput.addEventListener('paste', () => {
                    setTimeout(previewBatchWords, 100); // Delay to allow paste to complete
                });
            }
        });

        // Initialize the app when page loads
        window.addEventListener('load', initializeApp);
    </script>

    <script>
        // Replace addWord with:
        async function addWord() {
            const input = document.getElementById('newWordInput');
            const word = input.value.trim().toLowerCase();
            if (!word) return;

            if (currentRecordCount >= 999) {
                showMessage("Maximum limit of 999 words reached. Please delete some words first.");
                return;
            }
            if (currentWords.some(w => w.word === word)) {
                showMessage("This word already exists!");
                return;
            }

            showLoading(true);

            if (window.dataSdk) {
                const result = await window.dataSdk.create({
                    word,
                    difficulty: "basic"
                });
                if (result.isOk) {
                    input.value = '';
                } else {
                    showMessage("Failed to add word. Please try again.");
                }
            } else {
                // Fallback: update local state and UI
const localRecord = {
    word,
    difficulty: "basic",
    // Always give each record a unique ID so deleteWord() can find it
    __backendId: (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function")
        ? crypto.randomUUID()
        : "local-" + Date.now() + "-" + Math.floor(Math.random() * 1000)
};

currentWords.push(localRecord);
currentRecordCount = currentWords.length;
gameState.gameWords = currentWords.map(item => item.word);

// Refresh the UI
updateWordDisplay();

// Reset input
input.value = "";

// Optional: feedback toast
showMessage(`"${word}" added locally.`);

            }

            showLoading(false);
        }

        // Replace addBatchWords with:
        async function addBatchWords() {
            const input = document.getElementById('batchWordInput');
            const text = input.value.trim();
            if (!text) {
                showMessage("Please enter some words to import!");
                return;
            }

            const words = parseBatchWords(text);
            const existingWords = currentWords.map(w => w.word);
            const newWords = words.filter(word => !existingWords.includes(word));

            if (newWords.length === 0) {
                showMessage("No new words to import!");
                return;
            }
            if (currentRecordCount + newWords.length > 999) {
                showMessage(`Cannot import ${newWords.length} words. Maximum limit is 999 words total.`);
                return;
            }

            showLoading(true);

            let successCount = 0;
            let errorCount = 0;

            if (window.dataSdk) {
                for (const word of newWords) {
                    const result = await window.dataSdk.create({
                        word,
                        difficulty: "basic"
                    });
                    if (result.isOk) successCount++;
                    else errorCount++;
                }
            } else {
                // Fallback: add locally
                for (const word of newWords) {
                    const localRecord = {
                        word,
                        difficulty: "basic",
                        __backendId: (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') ? crypto.randomUUID() : String(Date.now() + Math.random())
                    };
                    currentWords.push(localRecord);
                    successCount++;
                }
                currentRecordCount = currentWords.length;
                gameState.gameWords = currentWords.map(item => item.word);
                updateWordDisplay();
            }

            showLoading(false);

            if (successCount > 0) {
                input.value = '';
                document.getElementById('batchPreview').classList.remove('show');
                showMessage(`Successfully imported ${successCount} words!`);
                switchTab(null, 'single'); // after fix below
            }
            if (errorCount > 0) {
                showMessage(`${errorCount} words failed to import. Please try again.`);
            }
        }
    </script>

    <script>
        (function () {
            function c() {
                var b = a.contentDocument || a.contentWindow.document;
                if (b) {
                    var d = b.createElement('script');
                    d.innerHTML =
                        "window.__CF$cv$params={r:'99671057b6fdbecb',t:'MTc2MTc4Njk1MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";
                    b.getElementsByTagName('head')[0].appendChild(d)
                }
            }
            if (document.body) {
                var a = document.createElement('iframe');
                a.height = 1;
                a.width = 1;
                a.style.position = 'absolute';
                a.style.top = 0;
                a.style.left = 0;
                a.style.border = 'none';
                a.style.visibility = 'hidden';
                document.body.appendChild(a);
                if ('loading' !== document.readyState) c();
                else if (window.addEventListener) document.addEventListener('DOMContentLoaded', c);
                else {
                    var e = document.onreadystatechange || function () {};
                    document.onreadystatechange = function (b) {
                        e(b);
                        'loading' !== document.readyState && (document.onreadystatechange = e, c())
                    }
                }
            }
        })();
    </script>
</body>

</html>